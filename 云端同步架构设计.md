# 极简云端同步架构设计方案

## 1. 项目现状分析（保持简单）

### 1.1 现有数据结构
基于 [`src/utils/share_type.ts`](src/utils/share_type.ts:48) 中的 Task 接口：
```typescript
interface Task {
  id: string           // UUID 主键
  name: string         // 任务名称
  estimatedTime: number // 预计时间（小时）
  longCycle: boolean   // 是否长周期模式
  cycleList: CycleItem[] // 番茄钟周期列表
  progress: number     // 进度
  deadline: number | null // 截止时间戳
  completed: boolean   // 完成状态
  time_up: boolean     // 时间到状态
  urgent: boolean      // 紧急状态
  important: boolean   // 重要状态
  description?: string // 描述
  timestamp: number    // 最后更新时间戳
}
```

### 1.2 现有存储架构
- 使用 [`tasksStore.ts`](src/stores/tasksStore.ts:27) 中的 localStorage 进行本地持久化
- 任务数据通过 Pinia store 管理
- 已实现自动保存和防抖机制

## 2. 极简云端同步架构

### 2.1 单文件架构
```
客户端(Vue3+Pinia) ◄──► server.js(单文件) ◄──► data.db(SQLite单文件)
```

### 2.2 极简认证
- **单Token认证**：无用户系统，仅Token
- **即开即用**：无需注册，生成Token即可使用

### 2.3 极简同步策略
1. **云端优先**：服务端数据为准
2. **单端点**：仅一个API接口
3. **全量替换**：客户端全量上传，全量下载

## 3. 极简远程服务器API设计

### 3.1 单端点API（仅一个接口）

#### 3.1.1 数据同步（唯一接口）
```
POST /sync
Headers:
  X-Token: {token}  # 简化认证头
  Content-Type: application/json

Request Body:
{
  "tasks": Task[]  # 仅必要字段：客户端全量任务数据
}

Response:
{
  "tasks": Task[]  # 仅返回数据：同步后的全量任务
}
```

#### 3.1.2 极简响应设计
- 无包装对象，直接返回数据
- 无状态码包装，使用HTTP状态码
- 错误时返回纯文本错误信息

### 3.2 服务端同步逻辑

#### 3.2.1 极简冲突解决算法
```javascript
function sync(clientTasks, serverTasks) {
  const merged = {}
  
  // 服务端数据优先（云端优先原则）
  serverTasks.forEach(task => {
    merged[task.id] = task
  })
  
  // 客户端更新（仅当客户端时间戳更新时）
  clientTasks.forEach(task => {
    const serverTask = merged[task.id]
    if (!serverTask || task.timestamp > serverTask.timestamp) {
      merged[task.id] = task
    }
  })
  
  return Object.values(merged)
}
```

#### 3.2.2 数据库设计（SQLite - 极简实现）
```sql
-- 用户表（Token为基础）
CREATE TABLE users (
  token TEXT PRIMARY KEY,  -- 直接使用token作为主键，极简设计
  created_at INTEGER DEFAULT (strftime('%s', 'now')),
  last_sync_at INTEGER
)

-- 任务表
CREATE TABLE tasks (
  id TEXT PRIMARY KEY,  -- Task UUID
  token TEXT NOT NULL,  -- 用户token，替代user_id外键
  name TEXT NOT NULL,
  estimated_time INTEGER,
  long_cycle INTEGER,  -- SQLite用INTEGER代替BOOLEAN
  cycle_list TEXT,  -- JSON数据用TEXT存储
  progress INTEGER DEFAULT 0,
  deadline INTEGER,
  completed INTEGER DEFAULT 0,
  time_up INTEGER DEFAULT 0,
  urgent INTEGER DEFAULT 0,
  important INTEGER DEFAULT 0,
  description TEXT,
  timestamp INTEGER NOT NULL,
  created_at INTEGER DEFAULT (strftime('%s', 'now')),
  updated_at INTEGER DEFAULT (strftime('%s', 'now'))
)

-- 极简索引
CREATE INDEX idx_tasks_token ON tasks(token)
CREATE INDEX idx_tasks_timestamp ON tasks(timestamp)
```

## 4. 前端设置页面集成设计

### 4.1 设置页面集成方案
将云端同步设置作为设置页面的一个功能模块，与其他设置项一起展示：

#### 4.1.1 设置页面结构
```vue
<!-- SettingsView.vue 或类似设置页面 -->
<template>
  <div class="settings-container">
    <!-- 通用设置 -->
    <n-card title="通用设置">
      <!-- 主题、语言等设置 -->
    </n-card>
    
    <!-- 云端同步设置 -->
    <n-card title="云端同步" class="sync-settings-card">
      <!-- 云端同步配置内容 -->
    </n-card>
    
    <!-- 其他设置模块 -->
  </div>
</template>
```

#### 4.1.2 设置页面路由配置
```javascript
// router/index.ts
{
  path: '/settings',
  name: 'settings',
  component: () => import('@/views/SettingsView.vue')
}
```

```vue
<!-- 在设置页面中添加云端同步配置模块 -->
<template>
  <div class="settings-container">
    <!-- 其他设置项... -->
    
    <!-- 云端同步设置模块 -->
    <n-card title="云端同步" class="sync-settings-card">
      <!-- 启用开关 -->
      <n-form-item label="启用云端同步">
        <n-switch v-model:value="syncEnabled" />
      </n-form-item>
      
      <!-- 同步配置（启用时显示） -->
      <div v-if="syncEnabled" class="sync-config">
        <!-- Token 配置 -->
        <n-form-item label="访问令牌">
          <n-input
            v-model:value="syncConfig.token"
            type="password"
            placeholder="输入您的访问令牌"
            show-password-on="click"
          />
          <n-button @click="generateToken" size="small">生成新令牌</n-button>
        </n-form-item>
        
        <!-- 服务器地址配置 -->
        <n-form-item label="服务器地址">
          <n-input
            v-model:value="syncConfig.baseUrl"
            placeholder="https://api.potatolism.com"
          />
        </n-form-item>
        
        <!-- 同步状态和操作 -->
        <n-form-item label="同步状态">
          <n-space align="center">
            <n-tag :type="syncStatus.type" size="small">
              {{ syncStatus.text }}
            </n-tag>
            <n-button @click="testConnection" size="small">测试连接</n-button>
            <n-button type="primary" @click="performSync" size="small">立即同步</n-button>
          </n-space>
        </n-form-item>
        
        <!-- 最后同步时间 -->
        <n-form-item label="最后同步" v-if="syncConfig.lastSync">
          <n-text depth="3">{{ formatLastSyncTime(syncConfig.lastSync) }}</n-text>
        </n-form-item>
      </div>
    </n-card>
  </div>
</template>
```

### 4.2 设置页面状态管理
在设置页面中管理云端同步的本地状态：

#### 4.2.1 设置页面状态结构
```javascript
// SettingsView.vue 中的状态管理
import { ref, computed } from 'vue'
import { useTasksStore } from '@/stores/tasksStore'

export default {
  setup() {
    const tasksStore = useTasksStore()
    
    // 设置页面的本地状态
    const settingsState = ref({
      syncEnabled: false,  // 是否启用同步
      syncConfig: {
        token: '',     // 访问令牌
        baseUrl: '',   // 服务器地址
        lastSync: 0    // 最后同步时间戳
      },
      syncStatus: 'idle'  // 同步状态：idle/syncing/synced/error
    })
    
    // 同步状态显示文本
    const syncStatusText = computed(() => {
      const statusMap = {
        idle: '未同步',
        syncing: '同步中...',
        synced: '已同步',
        error: '同步失败'
      }
      return statusMap[settingsState.value.syncStatus] || '未知状态'
    })
    
    // 同步状态标签类型
    const syncStatusType = computed(() => {
      const typeMap = {
        idle: 'default',
        syncing: 'warning',
        synced: 'success',
        error: 'error'
      }
      return typeMap[settingsState.value.syncStatus] || 'default'
    })
    
    return {
      settingsState,
      syncStatusText,
      syncStatusType
    }
  }
}
```

#### 4.2.2 设置页面同步方法
```javascript
// 设置页面的同步操作方法
const performSync = async () => {
  if (!settingsState.value.syncEnabled) return
  if (!settingsState.value.syncConfig.token || !settingsState.value.syncConfig.baseUrl) {
    window.$message.warning('请配置同步参数')
    return
  }
  
  settingsState.value.syncStatus = 'syncing'
  
  try {
    const response = await fetch(`${settingsState.value.syncConfig.baseUrl}/sync`, {
      method: 'POST',
      headers: {
        'X-Token': settingsState.value.syncConfig.token,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ tasks: tasksStore.tasks })
    })
    
    if (response.ok) {
      const data = await response.json()
### 4.3 设置页面数据持久化
将设置页面的云端同步配置持久化存储：

#### 4.3.1 配置持久化方法
```javascript
// 设置页面配置持久化
const SETTINGS_KEY = 'potato_sync_settings'

const saveSettings = () => {
  const settingsToSave = {
    syncEnabled: settingsState.value.syncEnabled,
    syncConfig: settingsState.value.syncConfig
  }
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(settingsToSave))
}

const loadSettings = () => {
  const saved = localStorage.getItem(SETTINGS_KEY)
  if (saved) {
    try {
      const parsed = JSON.parse(saved)
      settingsState.value.syncEnabled = parsed.syncEnabled || false
      settingsState.value.syncConfig = parsed.syncConfig || {
        token: '',
        baseUrl: '',
        lastSync: 0
      }
    } catch (error) {
      console.error('加载同步设置失败:', error)
    }
  }
}

// 监听设置变化，自动保存
watch(
  () => [settingsState.value.syncEnabled, settingsState.value.syncConfig],
  () => {
    saveSettings()
  },
  { deep: true }
)
```

#### 4.3.2 设置页面生命周期
```javascript
// 设置页面生命周期管理
onMounted(() => {
  loadSettings()
  // 如果启用了同步且有配置，检查连接状态
  if (settingsState.value.syncEnabled && settingsState.value.syncConfig.token) {
    testConnection()
  }
})

onUnmounted(() => {
  // 清理工作
  saveSettings()
})
```
      tasksStore.tasks = data.tasks  // 更新任务数据
      settingsState.value.syncConfig.lastSync = Date.now()
      settingsState.value.syncStatus = 'synced'
      window.$message.success('同步成功')
    } else {
      settingsState.value.syncStatus = 'error'
      window.$message.error('同步失败')
    }
  } catch (error) {
    settingsState.value.syncStatus = 'error'
    window.$message.error('网络错误')
  }
}

// 测试连接
const testConnection = async () => {
  if (!settingsState.value.syncConfig.baseUrl) {
    window.$message.warning('请输入服务器地址')
    return
  }
  
  try {
    const response = await fetch(`${settingsState.value.syncConfig.baseUrl}/health`, {
      method: 'GET',
      headers: {
        'X-Token': settingsState.value.syncConfig.token || 'test'
      }
    })
    
    if (response.ok) {
      window.$message.success('连接成功')
    } else {
      window.$message.error('连接失败')
    }
  } catch (error) {
    window.$message.error('网络错误')
  }
}

// 生成新Token
const generateToken = () => {
  settingsState.value.syncConfig.token = 'pt_' + Math.random().toString(36).substring(2, 15)
  window.$message.success('已生成新Token')
}

// 格式化最后同步时间
const formatLastSyncTime = (timestamp) => {
  if (!timestamp) return '从未同步'
  const date = new Date(timestamp)
  const now = new Date()
  const diff = now - date
  
  if (diff < 60000) return '刚刚'
  if (diff < 3600000) return `${Math.floor(diff / 60000)}分钟前`
  if (diff < 86400000) return `${Math.floor(diff / 3600000)}小时前`
  return date.toLocaleString('zh-CN')
}
```

## 5. 极简数据同步策略

### 5.1 单一冲突规则
- **云端优先**：服务端数据始终优先
- **时间戳更新**：仅当客户端时间戳更新时覆盖
- **懒惰保留**：所有数据都保留，不主动删除

### 5.2 极简安全性
- **Token验证**：简单头部验证
- **无加密**：普通文本存储（可后续添加）
- **无频率限制**：简化实现

## 6. 敏捷开发实现优先级（极简主义）

### 第一周：MVP核心功能
1. ✅ 单文件SQLite数据库设计
2. ✅ 基础REST API（仅/sync端点）
3. ✅ 客户端配置界面
4. ✅ 简单同步逻辑

### 第二周：稳定性优化
1. 错误处理和重试机制
2. 同步状态反馈
3. 基础测试用例

### 后续迭代（按需）
- 性能优化
- 高级冲突解决
- 统计分析功能

## 7. 技术选型建议

### 7.1 服务端技术栈（极简实现）
- **框架**：Node.js + Express（最简配置）
- **数据库**：SQLite（单文件数据库，零配置）
- **部署**：单文件部署，无需Docker
- **依赖**：最小化依赖，仅必要模块

### 7.2 客户端技术栈
- **HTTP 客户端**：axios / fetch API
- **状态管理**：Pinia（已使用）
- **UI 组件**：Naive UI（已使用）

## 8. 监控与维护

### 8.1 监控指标
- API 响应时间
- 同步成功率
- 冲突解决数量
- 用户活跃度

### 8.2 极简日志记录
- 错误日志（仅错误信息）
- 同步计数（成功/失败次数）
- 单文件日志，定期清理

这个架构设计保持了极简原则，无账号密码系统，使用 Token 进行身份验证，实现了云端数据优先的同步策略，同时保持了系统的可扩展性和可维护性。